\section{Matchertext in selected languages}
\label{sec:langs}

\subsection{URIs}

\subsection{C-like strings and character escapes}

A wide variety of languages have adopted C-like string literal syntax,
in which either single or double quotes surround a string literal,
and backslashes within the literal introduce escape sequences
used to include sensitive or special characters literally in the string
(\eg \verb|\'|, \verb|\"|, \verb|\\|, \verb|\n|, \verb|\t|, etc.).
There are two main ways in which we might wish to enhance such languages
to support matchertext,
depending on whether the language in question is the host language
or the embedded language.

\subsubsection{Hosting matchertext within C-like strings}


triple-quoted multiline comments

\subsection{SGML, HTML, XML}

CDATA sections -- specifically for embedded uninterpreted comment
to be interpreted literally (not as markup content).
Terminated with the first \verb|]]>| character sequence.
Of course we might hope that \verb|]]>| is unlikely to appear
in the embedded content, but it might --
and if it does, it will prematurely end the CDATA sequence
unless embedded \verb|]]>| are somehow escaped
\emph{within} that embedded content.
One scenario in which this might realistically be a problem
is if the "uninterpreted" CDATA content is in fact
text comprising a SGML, HTML, or XML document type definition (DTD),
which is likely to contain instances of the sequence \verb|]]>|
(see for example
\href{https://www.w3.org/TR/html4/sgml/dtd.html}{the HTML 4 DTD}).
Since CDATA sections are particularly useful
for including HTML or XML markup as literal text in a marked-up document --
\eg a document \emph{about} HTML, XML, or DTDs --
this is not a particularly unrealistic scenario.
The \href{https://en.wikipedia.org/wiki/CDATA}{Wikipedia page for CDATA}
even helpfully suggests that the ``preferred approach''
to work around this problem is to use multiple CDATA sections,
``splitting each occurrence of the triad
just before the ``\verb|>|''.

relevant:
\href{http://www.flightlab.com/~joe/sgml/cdata.html}{CDATA Confusion}


Potential extension: MDATA.
\verb|<![MDATA[|$m$\verb|]]>|,
where $m$ is any valid matchertext.
Thus, basically like CDATA except that
an instance of the \verb|]]>| triad within $m$
will \emph{not} prematurely end the MDATA section
provided that matchers within $m$ are properly matched.


\subsection{Regular expressions}

Character classes: no matchers unless both present.
But character escapes instead...

(XXX these should be discussed in C-like languages, not here.)

Potential conflicts:
- TCL RE syntax: \verb|\c|$X$ "(where $X$ is any character) the character whose low-order 5 bits are the same as those of $X$, and whose other bits are all zero"
WTF??
- PCRE syntax (and Perl?): \verb|\o{|$ddd$\verb|}| is character with octal code ddd.  Not a conflict if this usage always has non-empty ddd while \verb|\o{}| always means an open curly brace.

Perl supports escape sequences of the form \verb|\o{|$ddd$\verb|}|
denoting the ASCII character denoted by the octal digits $ddd$,
as an alternative to the traditional C octal escape syntax \verb|\|$ddd$,
that is less ambiguous with fewer than three octal digits.
This usage might appear to conflict with the potential introduction
of an escape sequence \verb|\o{}| denoting an open curly brace.
However, Perl treats a \verb|\o{|$ddd$\verb|}| sequence
with \emph{no} octal digits as a syntax error.
Thus, introducing \verb|o{}| as a matcher escape code
would not affect any currently-valid Perl code
and hence would be backwards compatible.
% see perl/escapes.pl for a trivial script with which to verify this.

Similarly, Raku uses \verb|\o[|$ddd$\verb|]| for octal escapes,
and uses \verb|\c[|$ccc$\verb|]|
for decimal or named character escapes.
In each case, however, Raku requires the bracket pair to be non-empty.
Thus, adding \verb|\o[]| and \verb|\c[]|
as open- and close-bracket escape sequences
would not affect existing valid Raku code.
% see raku/escapes.raku for a trivial script with which to verify this.

Tcl regular expression syntax includes an escape sequence form
\verb|\c|$X$ that provides an alternative method of expressing control codes
with ASCII values less than 0x20.
An escape code \verb|\c|$X$ takes the ASCII code for $X$
and masks the upper 3 bits to zero, yielding a control code.
Thus, \verb|\c@| yields NUL, the same as \verb|\000|,
\verb|\cA| or \verb|\ca| is the same as \verb|\001|, etc.
In a Tcl regular expression,
\verb|\c(| would be a rather perverse synonym for
the backspace (BS) control code --
which would more commonly be written \verb|\b|, \verb|\010|, or \verb|\x08|.
Both \verb|\c[| and \verb|\c{|
would be strange synonyms for the escape (ESC) control code --
the more conventional representations
being \verb|\e|, \verb|\033|, or \verb|\x1B| --
or even \verb|\c;|, the \verb|\c|$X$ synonym for ESC
whose character $X$ has the lowest ASCII code.
It seems unlikely that we will find ``legitimate'' Tcl code 
that uses \verb|\c(| for BS or \verb|\c[| or \verb|\c{| for ESC.
Technically such uses \emph{could} exist, however,
so adding \verb|\c()|, \verb|\c[]|, and \verb|\c{}| as a close-matcher escapes
would technically constitute a non-backwards-compatible extension to Tcl.

\textbf{Research question:}
In a large body of Tcl code, how often are \verb|\c| escape sequences used,
and how often are the equivalent sequences for introducing control codes used
(\eg single-letter sequences, or octal or hex numeric sequences)?
Which specific escape sequences does \verb|\c| get used for
and with which characters $X$?

Relevant: \href{https://www.tcl.tk/man/tcl8.5/tutorial/Tcl21.html}{More Quoting Hell - Regular Expressions 102}.
Also \href{https://wiki.tcl-lang.org/page/Quoting+hell}{Quoting hell}

\subsection{SQL?}

