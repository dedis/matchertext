\section{Matchertext design and rationale}
\label{sec:design}

\subsection{Abstract matchertext}

basic principle, given some set of matcher pairs --
but leaving the decision of which pairs for later in
\cref{sec:design:ascii}

Basic rule: in matchertext, \emph{matchers must match}.

Always-embeddability given that embedded string is valid matchertext.

We assume some alphabet $A$.
We further assuma a set $M$ of $k$ matcher pairs
$\{(o_1,c_1),\dots,(o_k,c_k)\}$,
where $o_1,\dots,o_k$ are \emph{openers} in $A$,
and $c_1,\dots,c_k$ are corresponding \emph{closers} in $A$.
Let the set $N$ of \emph{nonmatchers} be the subset of $A$
excluding openers and closers:
\ie $N = A \setminus \{o_1,\dots,o_n,c_1,\dots,c_n\}$.
A \emph{nonmatcher string} $n$ is a string of any finite length
(including empty)
consisting only of nonmatchers in $N$.

\xxx{Epsilon for alphabet, tradition.}

We can inductively define the language $L$ of \emph{matchertext strings}
as follows:
\begin{itemize}
\item	For any nonmatcher string $n$,
	$n$ is a matchertext string.
\item	For any matchertext string $m$,
	any corresponding open/close pair $(o_i,c_i) \in M$,
	and any nonmatcher strings $n_1$ and $n_2$,
	the concatenation $n_1\,o_i\,m\,c_i\,n_2$ is a matchertext string.
\end{itemize}

By construction, every opener is always paired
with the corresponding closer later in the string,
while nonmatchers may be interspersed without restriction.

By the above definition,
matchertext fulfills the classic definition of a syntactic \emph{language} --
namely a set of strings mathematically defined to be in the language.
In practice, however,
we will refer to matchertext as a \emph{syntactic discipline}
rather than a language
because matchertext is devoid of semantic meaning,
or even any syntactic structure outside the rule that ``matchers must match.''
Matchertext is intended only to provide a structural background rule
atop which any number of \emph{matchertext languages} may be defined,
each with its own syntax further constraining the set of valid strings,
and perhaps associating language-dependent semantic meaning to those strings.
In particular, we can in principle take any arbitrary language $L$
defined as a set of strings,
and define the \emph{matchertext subset} of $L$
simply as those strings $s \in L$ that are also matchertext strings.



\subsubsection{Character set and encoding}

The matchertext discipline does not dictate any particular choice
of character set or encoding.
For example, a matchertext string or text file could be in plain ASCII,
in Unicode/UCS encoded via UTF-8 or UTF-16,
in any of the numerous pre-Unicode character sets and encodings,
or in any subset of one of these character sets.
The matchertext rule merely states that
wherever the ASCII matchers
\verb|()[]{}|
%\verb|(|,\verb|)|,\verb|[|,\verb|]|,\verb|{|,\verb|}|
might appear in plain text,
they must occur in matched pairs.
A plain text string in a character set restricted to contain no ASCII matchers
is trivially matchertext,
because it by definition has no characters
that could violate the matchertext rule.

One implication of this orthogonality between the matchertext rule
and character set choice
is that residual syntactic issues may still arise
whenever a host language might ``disagree'' with an embedded language
on character set choices.
Matchertext addresses some embedding issues, but not all of them.
We will return to this issue later in \cref{sec:embed:mri:liberal}
when we consider character set constraints
in uniform resource identifiers (URIs).


\subsection{Embedding considerations}

If a host language $L_H$ wishes to embed a language $L_E$,
then in the contexts where strings of $L_E$ are expected,
$L_H$ must impose \emph{no} constraints on characters allowed
other than the matchertext discipline (matchers must match).
Further $L_H$ must not transform the embedded strings of $L_E$ in any way
while extracting and interpreting the embedded string.
Specifically, any escaping mechanisms or other transformations
that might normally apply to text in $L_H$
must be disabled in the context of the embedded string.
If any escaping mechanisms or other transformations
are active within the embedded string,
those must be that of $L_E$, not $L_H$.

\xxx{Example with MRIs?}

\xxx{Formalization?}


\subsection{Why must the matchers be standardized?}



\subsection{Why ASCII matchers?}
\label{sec:design:ascii}

Why the ASCII matchers?
To achieve interlanguage embeddability,
we must agree on a cross-language standard for what character pairs
pairs the sensitive matchers are.
There is a strong tradition among most text-based machine-readable languages
to use the ASCII punctuation characters -- and mostly \emph{only} those --
as sensitive characters delimiting structural concepts
and denoting hierarchical relationships.
In particular, the three ASCII matcher pairs --
the parentheses `\verb|(|',`\verb|)|',
the square brackets `\verb|[|',`\verb|]|',
and the curly braces `\verb|{|',`\verb|}|' --
are almost always used in matched pairs
(if used for syntactically-sensitive purposes at all)
in most programming languages and other machine-readable syntaxes.


Why all the ASCII matchers?  More redundancy, more robustness
to undetected accidental errors or bugs.

Why not the ASCII angle brackets?

Why not the Unicode matchers too?


\subsection{Writing matchertext in existing languages}

In most popular langguages whose input is normally plaintext,
it is already \emph{possible} -- using existing escaping mechanisms --
to write a matchertext version
(either manually or automatically)
that is at least semantically equivalent
to any given valid plaintext string in that language.

Consider URIs, for example,
which have a standard percent-escape code mechanism
to replace potentially-sensitive ASCII characters with hexadecimal escape codes.
By RFC XXX, URIs are normally not supposed to contain square brackets anyway
except in matched pairs as part of IPv6 address syntax.
But URIs may contain parentheses and curly braces (XXX ?),
which might be unmatched in an arbitrary URI.
Such an URI can always be rewritten
into a semantically-equivalent matchertext URI
(i.e., one that evaluates to the same canonical form XXX)
by replacing all unmatched matcher characters with their
equivalent percent-escape codes.
For example, the URI `\verb|scheme://site/open(|'
would become `\verb|scheme://site/open%28|',
`\verb|scheme://site/close)|'
becomes `\verb|scheme://site/close%29|'
and `\verb|scheme://site/close)open(|' becomes
`\verb|scheme://site/close%29open%28|'.
The URI `\verb|scheme://site/open(close)|'
need not be rewritten at all,
since all the matchers it contains already (happen to) match.

In SGML-derived languages such as HTML and XML, similarly,
any valid plaintext string in the language
can generally be converted to an equivalent matchertext string
simply by replacing all unmatched ASCII matchers
with the decimal escape codes
`\verb|&#40;|', `\verb|&#41;|' or
`\verb|&lpar;|', `\verb|&rpar;|' for parentheses,
`\verb|&#91;|', `\verb|&#93;|' or
`\verb|&lbrack;|', `\verb|&rbrack;|' for square brackets, and
`\verb|&#123;|', `\verb|&#125;|' or
`\verb|&lbrace;|', \verb|&rbrace;|' for curly braces.

This does not mean that rewriting unmatched matchers into moderately-obscure
(especially numeric) escape codes
is particularly convenient or enjoyable to do manually, of course.
Fortunately, given the prevalence with which ASCII matchers
tend to be used in properly-matched fashion anyway --
both in programming languages and in free-form human-language text strings --
there is at least hope that we need not worry about escaping unmatched matchers
\emph{all the time}.
(XXX we will explore this question of frequency in the evaluation.)
But \emph{sometimes} we will still need to express
unmatched matcher characters in many languages --
when we are trying to ``talk about'' those matchers
as \emph{literal characters}, for example,
whether in code or human-readable text.

\subsection{Matchers in character and string literals}

It is near-ubiquitous practice in mainstream programming languages 
to use the ASCII single- and/or double-quote characters (\verb|'|, \verb|"|)
to delimit literal characters or strings.

\subsection{Gracefully evolving towards matchertext-friendly languages}

We can envison backwards-compatible extensions to most popular languages
that could 


\subsection{Unmatched matchers in comments}


