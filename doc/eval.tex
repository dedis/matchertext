\section{Evaluation}
\label{sec:eval}

This section is a placeholder at present,
pending more implementation and evaluation experience to report.

Some key questions we wish to evaluate include:
\begin{itemize}
\item	What are the most common kinds of embeddings
	that appear in large repositories of real source code,
	in what host and embedded language combinations,
	and for what purposes?
\item	How common and what kinds of needs are there for
	multiple levels of embedding in practice?
\item	For a set of popular (big or little) languages,
	how common are natural violations of matchertext discipline?
	Of what kinds are most common (e.g., in string constants, comments)?
	How painful would it be to fix these violations in typical code?
\item	How common and painful are needs to escape embedded strings
	when manually embedding into surrounding language strings?
	For example, how commonly do actual URIs embedded into
	actual program code need or use manual escaping?
\item	How common have security bugs been related to
	inadequate or incorrect escape armoring
	when embedding untrusted content automatically?
\item	What is the security-critical ``attack surface''
	(\eg code size and complexity)
	of typical string sanitizing mechanisms
	for embedding of untrusted content?
\item	What are the syntactic ``horror stories'' of cross-language embedding,
	akin to leaning toothpick syndrome,
	but perhaps in other combinations of languages
	and/or resulting in other symptoms?
\end{itemize}


\xxx{Prevalence of embedding versus unmatched matchers:

The key advantage of matchertext is to simplify embedding,
but it has the cost of making it more cumbersome
to express unmatched matchers.
Is this a worthwhile tradeoff?

\textbf{Experiment:}
For each of several popular programming languages,
(a) find a large repository of source code in that language
(\eg an open source software distribution);
(b) find a mature scanner/parser for that language;
(c) write a heuristic recognizer for a variety
of commonly-embedded strings in other ``big'' or ``little'' language syntaxes
(\eg regexes, URIs, IP addresses, JavaScript, $dots$);
(d) count the number of times that cross-language embeddings
appear in some form,
and the number of times that unmatched matchers appear.
Record and provide statistics on the contexts in which embeddings
and unmatched matchers appear
(\eg in function calls, if statements, case statements, comments, $dots$).

Priority languages to evaluate include:
HTML (especially detecting embedded JavaScript);
JavaScript/TypeScript (especially with embedded HTML);
C, C++, Java, Go, Swift, Perl, Raku, PHP.

It would probably be worth trying to
make the heuristic embedded string recognizer portable across languages
or find an existing one that is in some way.

}

