\section{Host language considerations}
\label{sec:host}

This section focuses on considerations for,
and potential extensions to,
languages that may wish to \emph{host}
matchertext strings in other languages
and provide the convenience of ``cut-and-paste'' embedding.
\Cref{sec:embed} will later discuss considerations
for languages wishing to \emph{be embedded} conveniently.
Both sets of considerations are relevant
to languages wishing to be maximally ``matchertext-friendly'' of course.
We present host-language and embedded-language considerations separately,
however,
in order to emphasize their conceptual orthogonality:
a language could readily adopt hosting extensions but not embedding extensions,
or vice versa.

One important observation is that
languages need not \emph{be} matchertext-compliant in their syntax
just in order to \emph{host} embedded matchertext.
Existing languages can preserve full compatibility
with all their existing (non-embedded, non-matchertext) code --
continuing to allow unmatched matchers in string constants for example --
while incrementally adding extensions that make it easy
to embed matchertext strings verbatim within the host language.
This form of backward compatibility will be essential
to the incremental adoption of matchertext.


\subsection{C-like host languages}

An enormous variety of today's popular programming languages
are derived, either closely or loosely, from C~\cite{kernighan88c}.
Though differing widely in purpose, philosophy, and semantics,
a vast number of these C-inspired languages share similar syntax
for string literals.
In particular, most C-derived languages use
double and/or single quotes to delimit a string literal,
and backslash escape codes to insert ``special'' characters within the literal:
\eg \verb|"hello!\n"|.
Because quoted string literals
are the primary existing syntactic mechanism
for embedding (non-matchertext) strings traditionally,
they represent a natural starting point for considering matchertext extensions.

Given the ubiquity of backslash-escaped string literals,
we suggest that one reasonable extension for hosting matchertext
in C-like languages is via a new escape sequence,
such as \verb|\[|m\verb|]|,
where $m$ is arbitrary matchertext.
The embedded matchertext $m$ is uninterpreted by the host language processor
except to verify that ASCII matchers match
and to find the terminating close bracket.
Thus, quote characters, backslashes, whitespace, newlines,
or other control codes cease being ``special'' within the matchertext $m$ --
at least from the perspective of the host language.
For example, the string literal \verb|"\["'\]"|
becomes equivalent to \verb|"\"\'\\"|.
These and other characters might of course be ``special'' with respect to
whatever embedded language $m$ might be written in.

\subsubsection{Some syntactic alternatives}

The above proposal is only one of many possible alternatives of course,
which may be worth considering --
especially in the context of specific programming languages.
We briefly discuss a few ``obvious'' alternatives, however,
that seem less preferable for various pragmatic reasons.

The tradition of using quotes to delimit string literals
is unfortunate in terms of matchertext's ``cut-and-paste embedding'' goal.
Both the ASCII double quote (\verb|"|)
and the ASCII ``single quote'' (\verb|'|) --
technically standardized as an apostrophe and not a quote --
are ``undirected'' and do not come in matched pairs,
so C-style quoted strings do not naturally nest.
Unicode offers directed quote characters
intended for use in matched pairs,
but they are harder to type directly on most keyboards,
and are traditionally used in human-readable languages
rather than programming languages.
Also, the question of \emph{which} Unicode quote characters go together
is heavily language- and culture-dependent:
\eg “English”, „German“, «French», »Danish«, etc.
Thus, there is no obvious language-neutral way to choose and define
a particular set of Unicode directed-quote characters as matcher pairs.
Without doing that,
quote characters are not useful to host embedded matchertext,
because the ``matchers must match'' rule would not be sufficient
for the host language processor
to find the end of a matchertext string reliably.

Using ASCII matchers alone as new ``matchertext string literal'' delimiters --
like \verb|(|$m$\verb|)|, \verb|[|$m$\verb|]|, or \verb|{|$m$\verb|}| --
would obviously conflict with
many other long-established and doubtless higher-priority syntactic uses,
such as expression grouping \verb|a*(b+c)|, tuples \verb|(a,b)|,
lists \verb|[a,b]|, sets \verb|{a,b}|, and maps \verb|{a=1,b=2}|.

Nested \emph{combinations} of quotes and ASCII matchers --
such as \verb|["|$m$\verb|"]| or \verb|"[|$m$\verb|]"| or similar --
might also be initially appealing.
In most C-like languages, however,
such combinations would similarly conflict
with combinations of existing syntactic constructs
that are not unlikely to appear in existing code:
\eg a list whose sole element is a string literal, like \verb|["x"]|,
or a string literal containing brackets, like \verb|"[x]"|.
Using more deeply-nested matchers -- \eg \verb|[["|$m$\verb|"]]| --
only pushes these syntactic conflicts deeper
(a singleton list of a singleton list of a string literal).
Considering the other ASCII matchers (parentheses or curly braces)
does not improve the situation much.

Embedding matchertext in a string literal via a new escape sequence
also has the advantage that the \emph{entire} literal need not be matchertext.
Literals can mix matchertext with conventional literal text
including host-language escape sequences:
\eg \verb|"\t\[let's indent]\n\t\[a "quote"]"|.

The choice of square brackets for the proposed matchertext escape sequence
is somewhat arbitrary:
we could instead use use parentheses or curly braces,
or a longer sequence such as \verb|\m[|$m$\verb|]|.
Any choice may conflict with existing syntax in \emph{some} language:
\eg
\verb|\(|$m$\verb|)| conflicts with
\href{https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID292}{string interpolation in Swift},
\verb|\[|$m$\verb|]| conflicts with
\href{https://www.php.net/manual/en/language.types.string.php}{octal character escapes in PHP},
and
\verb|\{|$m$\verb|}| conflicts with
\href{https://ceylon-lang.org/documentation/1.3/reference/literal/string/}{Unicode escapes in Ceylon}.
Fortunately, different languages need not agree on
the precise syntax for hosting matchertext strings,
and can choose whatever syntax best suits that particular language.
To fulfill matchertext's main objective,
different languages need to agree \emph{only} on the basic rule
that the embedded string itself is arbitrary except that
ASCII matchers must match.


\subsection{SGML-style markup host languages}

While the venerable
Standard General Markup Languages (SGML)~\cite{iso8879sgml}
itself has waned in popularity,
its derivatives HTML~\cite{whatwg22html} and XML~\cite{w3c08xml}
are now ubuiquitous in Web content and programming.
Wherever the differences between these markup languages is not important,
we will refer to them all as \ml languages.

In their basic role as markup languages
used to produce rich, structured documents,
\ml languages frequently play ``host'' to embedded strings
in countless other languages:
typically, in the language(s) of software or APIs
that a marked-up document is written about.
Embedding code in other languages as verbatim text
is a basic and frequently-used purpose of HTML's
\verb|<code>| and \verb|<pre>| tags,
for example.
Beyond merely marking up verbatim text in other languages, however,
HTML in particular has evolved to include special-purpose support
for embedding several other languages within HTML:
namely scripting languages such as JavaScript or Tcl,
cascading style sheets (CSS)~\cite{XXX},
MathML~\cite{XXX},
and SVG~\cite{XXX}.

The \ml languages are surprisingly complex syntactically,
especially given their simple-sounding purpose
of ``merely'' describing structured markup of usually human-readable text.
In particular,
there are at least three different syntactic contexts
in which strings in other languages are often embedded
into \ml languages --
and in which three different sets of quoting and escaping rules apply.
Embedded strings are often embedded
(1) as the content of an element,
(2) as an attribute within an element's start tag, or
(3) as verbatim text within a CDATA section.
We address each of these syntactic contexts in turn,
in each case suggesting potential matchertext extensions
that could help mitigate the various forms of ``escaping hell''
that these embedding contexts can create.

\begin{figure*}
\begin{center}
\begin{footnotesize}
\begin{tabular}{lrl}
\multicolumn{3}{l}{\textbf{(a) Embedding strings in other languages as element content, in standard HTML or with matchertext hosting extensions (+M):}} \\
& HTML	& \verb|<code>printf("Hello world!");/code>| \\
& +M	& \verb|<code [printf("Hello world!");]>| \\
& HTML	& \verb|<code>printf("Example &lt;b&gt;bold&lt;/b&gt; and &amp;bigstar; reference in HTML");]>| \\
& +M	& \verb|<code [printf("Example <b>bold</b> and &bigstar; reference in HTML");]>| \\
& HTML	& \verb|<script>document.getElementById("demo").innerHTML = "Hello world!";</script>| \\
& +M	& \verb|<script [document.getElementById("demo").innerHTML = "Hello world!";]>| \\
& HTML	& \verb|<script>document.getElementById("demo").innerHTML = "a <" + "/script> end tag";]>| \\
& +M	& \verb|<script [document.getElementById("demo").innerHTML = "a </script> end tag";]>| \\
\\
\multicolumn{3}{l}{\textbf{(b) Embedding strings in other languages within element attributes, in standard HTML or with matchertext extensions (+M):}} \\
& HTML	& \verb|<button onclick="okClicked()">OK</button>| \\
& +M	& \verb|<button onclick=[okClicked()]>OK</button>| \\
& HTML	& \verb|<button onclick="emitCharacter('\'')">Emit Apostrophe</button>| \\
& +M	& \verb|<button onclick=[emitCharacter("'")]>Emit Apostrophe</button>| \\
\\
\multicolumn{3}{l}{\textbf{(b) Embedding strings in within CDATA (character data) sections, in standard XHTML or with matchertext extensions (+M):}} \\
& XHTML	& \verb|<code>example <![CDATA[<b>bold</b>]]> markup</code>| \\
& +M	& \verb|<code>example <![MDATA[<b>bold</b>]]> markup</code>| \\
& XHTML	& \verb|<code>example <![CDATA[<![CDATA[character data]]]]><![CDATA[>]]> markup</code>| \\
& +M	& \verb|<code>example <![MDATA[<![CDATA[character data]]>]]> markup</code>| \\
& XHTML	& \verb|<code>example <![CDATA[<![CDATA[<![CDATA[double embedded]]]]]]>| \\
&	& \verb|<![CDATA[><![CDATA[>]]]]><![CDATA[>]]> markup</code>| \\
& +M	& \verb|<code>example <![MDATA[<![MDATA[<![MDATA[double embedded]]>]]>]]> markup</code>| \\
\end{tabular}
\end{footnotesize}
\end{center}
\caption{Examples of embedded strings in standard \ml languages,
	and with proposed matchertext extensions (+M).}
\label{fig:ml-emb}
\end{figure*}


\subsubsection{Strings embedded as element content}

One common form of embedding into \ml 
is marked-up text serving as the content of an element:
\eg example code between \verb|<code>| and \verb|</code>| tags
or between \verb|<pre>| and \verb|</pre>| tags in HTML.
Further, the \verb|<script>| and \verb|<style>| tags in HTML
exist specifically to embed scripting language code
and cascading style sheet (CSS) code, respectively,
as their content.

The syntactic rules governing
what can appear in text embedded as element content,
however,
depend intricately on the tag, the \ml language in question,
and even the language version.
In most elements such as \verb|<code>| and \verb|<pre>|,
any characters \verb|<| and \verb|&| appearing in the embedded string
must be escaped (as \verb|&lt;| and \verb|&amp;|),
to prevent the \ml parser misinterpreting them as
the start of a tag or a character reference,
respectively.
In XML, this rule applies to the content of all elements,
including the content of \verb|<script>| and \verb|<style>| tags
of XML-based XHTML.
In HTML, however, the content of \verb|<script>| and \verb|<style>| tags
is raw character data,
uninterpreted by the HTML parser except to find the end tag.
The content of such tags therefore \emph{can} contain
unescaped \verb|<| and \verb|&| characters --
and \emph{cannot} use HTML character entity references for escaping.
In HTML4, this uninterpreted content is terminated
by the first instance of a \verb|</| character sequence,
whether or it is part of the corresponding end tag
(\verb|</script>| or \verb|</style>|).
HTML5 in contrast terminates the content with a sequence \verb|</|
followed by the appropriate end tag name.
In all of these cases, figuring out what \emph{must be},
what \emph{can be}, and what \emph{cannot be}
escaped is subtle and potentially confusing.

As a potential extension enabling any of the \ml languages
to host embedded matchertext conveniently,
we suggest the following new element syntax:

\begin{center}
\verb|<|\emph{name attributes }\verb|[|\emph{matchertext content}\verb|]>|
\end{center}

The \emph{name} and \emph{attributes} are the tag name and optional attributes
as they normally appear in a start tag,
and \emph{matchertext content} is the element content as literal matchertext
enclosed in square brackets,
uninterpreted except to find the end by matching matchers.
This syntax represents the entire element,
with no end tag,
so it is more concise than traditional start/end tag pairs.
Since the content within brackets is uninterpreted except to match matchers,
the content cannot contain further markup (child elements)
or \ml character entity references when using this syntax.

\Cref{fig:ml-emb}(a) illustrates a few examples
of embedding JavaScript into a \verb|<code>| or \verb|<script>| element,
either in standard HTML or with the proposed matchertext content syntax (+M).
The first and third examples embed trivial and non-problematic code.
The second example shows the embedding of literal HTML markup within HTML.
The fourth example illustrates the more troublesome corner case
where embedded JavaScript wishes to output
a \verb|</script>| end tag within a string literal.
Since HTML entity references are unavailable within a \verb|<script>| element,
the code must either use JavaScript escapes,
or construct the \verb|</script>| tag from two string literals,
to prevent the embedded literal from prematurely ending
the \verb|<script>| element.
In matchertext content syntax,
neither example is problematic and both are more concise.


\subsubsection{Strings embedded as attribute values}

Besides element content,
scripting language code is often embedded in the attribute values
of \ml start tags,
most commonly to handle events in active user interface elements.
Attribute values represent a different syntactic context
in which different escaping rules apply.
When attribute values are delimited with single or double quotes,
the quote character that introduced the value must be escaped
(as \verb|&apos;| or \verb|quot;|)
if it is embedded in the attribute value.
Character references may appear and are substituted in attribute values,
like normal elements such as \verb|<code>| in HTML
but unlike \verb|<script>| or \verb|<style>| content.
As \href{https://www.w3.org/TR/html401/appendix/notes.html#notes-specifying-data}{the HTML specification notes},
this means that script and style data cannot be simply
cut-and-pasted between element content and attribute values
without care for the changed escaping rules.
HTML forgivingly allows \verb|<| and ``unambiguous'' \verb|&| characters
to appear unescaped in attribute values,
while XML requires them to be escaped (along with the active quote character).

One potential matchertext hosting extension
would be simply to allow square brackets as a third ``quoting style''
for attribute values,
where the text between the brackets is uninterpreted
except to match matchers and find the end.
With this extension as well as that above,
the quoting and escaping rules for matchertext element content
and matchertext attribute values would be identical,
allowing code to be cut-and-pasted between these contexts freely.

\Cref{fig:ml-emb}(b) illustrates
script text embedded in attribute values,
without and with matchertext hosting extensions.
The second example illustrates how any time
a string literal is needed in such embedded text,
the embedding effectively ``consumes'' both quote characters
in standard HTML or XHTML.
Matchertext embedding, in contrast,
preserves JavaScript's ``syntactic freedom''
of using one quote character to quote a verbatim instance of the other.


\subsubsection{Strings embedded in CDATA sections}

A third syntactic context in which strings are embedded in SGML and XML
(but not HTML)
is via CDATA sections of the form \verb|<![CDATA[|\emph{text}\verb|]]>|,
where \emph{text} is mostly-uninterpreted character data.
CDATA \emph{sections} are distinct from
CDATA-typed \emph{entities} or \emph{attributes}
as declared in an SGML document type definition (DTD).
CDATA sections offer the ``greatest protection''
from typical \ml escaping requirements,
in that \emph{only} the section-terminator sequence \verb|]]>|
is disallowed within the embedded text.
Because \ml escape sequences are unavailable within CDATA sections, however,
they also require the most-awkward syntactic contortions
in the hopefully-rare event that a \verb|]]>| sequence
needs to appear in an embedded string.
This ``worst-case scenario'' readily comes to pass
whenever one is \emph{writing about} CDATA sections and their issues
in a \ml markup language, for example.

A straightforward extension to host matchertext in a CDATA-like section
would be simply to add a matchertext section form
such as \verb|<![MDATA[|\emph{matchertext}\verb|]]>|,
where \emph{matchertext} is uninterpreted matchertext.
\Cref{fig:ml-emb}(b) illustrates three examples of markup
using CDATA sections versus corresponding MDATA sections.
The first example is simple and non-problematic in either case.
The second example illustrates how MDATA sections eliminate the problem
of embedding a \verb|]]>| sequence within such a verbatim section --
provided that matchers still match, of course.
The third example shows the more-extreme case of ``double embedding'' --
where the complexity and visual obfuscation of CDATA sections explodes,
while MDATA sections nest arbitrarily with no difficulty.
This double-embedding scenario might seem contrived,
but it is exactly what is needed, for example,
when attempting to write in \ml markup a visual example
(\eg in a \verb|<code>| block)
of the single-embedding problem and its typical ``preferred'' solution
of replacing \verb|]]>| sequences with \verb|]]]]><![CDATA[>| sequences
to ``close and reopen'' the outer CDATA section.


\subsection{Resource Identifiers}
\label{sec:host:ri}



