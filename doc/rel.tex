\section{Related Work}
\label{sec:rel}

The theory of syntactic structures,
such as regular and
context-free languages~\cite{chomsky59algebraic}
or parsing expression grammars~\cite{ford04popl},
has already been richly developed.
Nothing about the matchertext discipline
is particularly new or technically challenging
from a formal language perspective.
However, surprisingly little prior work has focused on
the ubiquitous practice of synactically embedding
strings of one language into those of another,
or addressing the practical challenges this embedding creates.

Some recent work has focused on developing better tooling
to support string-embedding practices as they currently stand:
\eg parsing regular approximations
of string-embedded languages~\cite{verbitskaia15relaxed},
and support in
integrated development environments~\cite{grigorev14string}
and static analysis tools~\cite{khabibullin15development}.
This work does not attempt to explore syntax design practices
that could make languages more cleanly embeddable in the first place, however.

Significantly more work has focused on
\emph{domain specific embedded langauges}
or DSELs~\cite{hudak98modular},
particularly in the functional programming community.
DSELs build upon the syntax and semantics
of a general-purpose programming language such as Haskell,
and thus benefit from --
but also become dependent upon and specialized to --
the syntax, semantics, and tooling of the host language.
DSELs are thus unsuitable for embedded languages
that wish to remain agnostic to, or usable across a variety of,
host languages.
Asking an embedded language to conform only to the matchertext discipline --
that ASCII matchers must match --
is a much more lightweight proposition than
asking the embedded language to adopt, and become usable \emph{only} with,
the entirety of Haskell or another general-purpose programming language.

Pragmatically,
some existing languages come close to the matchertext approach to embedding.
Strings in PostScript~\cite{adobe99postscript}
are delimited by matching parentheses,
and may contain unescaped literal parentheses provided they are balanced.
The \verb|dc| calculator~\cite{howard21dc}
similarly delimits strings with brackets,
and allows balanced nested brackets.
\href{https://spec.commonmark.org/0.30/#links}{Link syntax}
in Markdown~\cite{macfarlane19commonmark},
like \verb|[|\emph{text}\verb|](|\emph{url}\verb|)|,
allows brackets within \emph{text}
and parentheses within \emph{url} provided they are balanced.
These languages use traditional backslash escapes to handle unbalanced matchers,
however,
and do not support general cross-language embedding
in the way matchertext does.

\xxx{ in this space, not sure if we should go into more detail:
\href{https://www.cambridge.org/core/services/aop-cambridge-core/content/view/4B0A7526CC16907F445CCF27277E9B9B/S0956796802004574a.pdf/div-class-title-compiling-embedded-languages-div.pdf}{Compiling embedded languages},
\href{https://ieeexplore.ieee.org/document/685738}{Modular domain specific languages and tools}
\href{https://scg.unibe.ch/archive/papers/Reng10aEmbeddingLanguages.pdf}{Embedding Languages Without Breaking Tools}
}

This related work is preliminary and no doubt incomplete;
proposals for relevant additions are welcome.

